<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shakespeare JSON Viewer</title>
  <link rel="icon" href="data:," />
  <style>
    :root{
      --bg:#0b0b0c; --surface:#101113; --text:#e7e7e7; --muted:#a3a3a3;
      --accent:#b08cff; --border:#2a2d31; --sidebar-w:320px; --reading-w:70ch; --lh:1.6;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#fafafa; --surface:#fff; --text:#121212; --muted:#4b5563; --accent:#5b3fd6; --border:#e5e7eb; }
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:16px/var(--lh) system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,ui-sans-serif}
    header{position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:.75rem;padding:.75rem 1rem;border-bottom:1px solid var(--border);background:var(--surface)}
    header h1{font-size:1rem;margin:0;font-weight:600;letter-spacing:.02em}
    .layout{display:flex;min-height:calc(100vh - 56px)}
    aside{width:var(--sidebar-w);border-right:1px solid var(--border);padding:1rem;overflow:auto;background:var(--surface)}
    main{flex:1;min-width:0;display:flex;flex-direction:column}
    #toolbar{display:flex;align-items:center;justify-content:space-between;gap:.75rem;padding:.75rem 1rem;border-bottom:1px solid var(--border);background:var(--surface)}
    .toolbar-group{display:flex;align-items:center;gap:.5rem}
    #toolbar button{border:1px solid var(--border);background:transparent;color:var(--text);padding:.35rem .6rem;border-radius:.5rem;font:inherit;cursor:pointer}
    #toolbar button:disabled{opacity:.4;cursor:default}
    #crumbs{font-weight:600;text-align:center;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    #content{padding:1.25rem clamp(1rem,6vw,3rem);max-width:var(--reading-w);width:100%;margin:0 auto}
    .heading.scene,.heading.title{margin:.5rem 0 1rem;font-size:1.25rem}
    h1.unit{font-size:1.4rem;margin:.5rem 0 1rem}
    .stage{font-style:italic;color:var(--muted);margin:.25rem 0}
    .speech{margin:.75rem 0 1rem}
    .speaker{margin:.75rem 0 .25rem;font-weight:700;font-size:.95rem;color:var(--accent);text-transform:capitalize}
    .line{margin:.1rem 0;display:grid;grid-template-columns:minmax(4ch,auto) 1fr;gap:.75rem;align-items:flex-start}
    .line-number{color:var(--muted);font-variant-numeric:tabular-nums;text-align:right;user-select:text}
    .line-text{white-space:pre-wrap}
    .token{cursor:pointer;display:inline;border-radius:.2rem;padding:0 .1rem;margin:0 -.1rem;transition:background-color .15s ease,color .15s ease}
    .token:hover{background:rgba(176,140,255,.18)}
    .token.selected{background:rgba(176,140,255,.35);color:var(--accent)}
    .token.copied{background:rgba(176,140,255,.35);color:var(--accent)}
    .token.em{font-style:italic}
    .line[data-line]{cursor:pointer}
    .line.selected{background:rgba(176,140,255,.18);border-radius:.35rem}
    .line.selected .line-number{color:var(--accent)}
    .play summary{cursor:pointer;font-weight:600}
    .play small.muted{color:var(--muted);font-weight:500}
    ul.scenes{list-style:none;padding:.25rem 0 .5rem .25rem;margin:0;display:grid;gap:.35rem}
    .act-group{margin:.35rem 0 0}
    .act-header{display:flex;align-items:center;gap:.5rem;margin:.4rem 0 .15rem}
    .act-title{font-size:.85rem;font-weight:600;color:var(--muted);text-transform:uppercase;letter-spacing:.04em;flex:1}
    .scene-items{list-style:none;margin:0;padding:0;display:grid;gap:.2rem}
    .scene-item{display:flex;align-items:center;gap:.35rem}
    .scene-item .scene-link{flex:1;min-width:0}
    a.scene-link{color:inherit;text-decoration:none;border-radius:.35rem;padding:.2rem .35rem;display:inline-block}
    a.scene-link:hover{background:rgba(176,140,255,.18)}
    a.scene-link.active{background:rgba(176,140,255,.35)}
    .error{white-space:pre-wrap;background:#ffeded0f;border:1px solid #fca5a5;color:#fecaca;padding:1rem;border-radius:.5rem}
    .act-copy{border:1px solid var(--border);background:transparent;color:var(--text);padding:.2rem .45rem;border-radius:.35rem;font:inherit;font-size:.75rem;cursor:pointer;line-height:1}
    .act-copy:hover:not(:disabled){background:rgba(176,140,255,.18)}
    .act-copy:disabled{opacity:.4;cursor:default}
    #selection{display:none;align-items:center;gap:.75rem;padding:.6rem 1rem;border-bottom:1px solid var(--border);background:rgba(176,140,255,.12)}
    #selection.active{display:flex}
    #selection strong{font-variant-numeric:tabular-nums;letter-spacing:.02em}
    #selection button{border:1px solid var(--border);background:transparent;color:var(--text);padding:.35rem .6rem;border-radius:.5rem;font:inherit;cursor:pointer}
    .visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    @media (min-width:1100px){
      #content{max-width:min(1100px,92vw)}
      .line{grid-template-columns:minmax(4ch,auto) minmax(0,max-content)}
      .line-text{white-space:nowrap}
      main{overflow-x:auto}
    }
    @media (max-width:920px){
      aside{display:none}
      main{border-left:none}
      .line-text{white-space:pre-wrap}
    }
  </style>
</head>
<body>
  <header><h1>Shakespeare JSON Viewer</h1></header>
  <div class="layout">
    <aside><div id="plays"></div></aside>
    <main>
      <div id="toolbar">
        <div class="toolbar-group">
          <button id="prev" disabled>← Prev</button>
        </div>
        <div id="crumbs">Loading…</div>
        <div class="toolbar-group">
          <button id="copy-play" disabled>Copy text</button>
          <button id="next" disabled>Next →</button>
        </div>
      </div>
      <p id="copy-feedback" class="visually-hidden" aria-live="polite"></p>
      <div id="selection" role="status" aria-live="polite">
        <span id="selection-label"></span>
        <div style="margin-left:auto;display:flex;gap:.5rem;align-items:center">
          <button id="copy-selection">Copy range</button>
          <button id="clear-selection">Clear</button>
        </div>
      </div>
      <article id="content" aria-live="polite"></article>
    </main>
  </div>

  <script defer>
  (function(){
    'use strict';
    const $ = s => document.querySelector(s);
    function el(tag, attrs={}, ...kids){
      const n = document.createElement(tag);
      for (const [k,v] of Object.entries(attrs)){
        if (k==='class') n.className=v;
        else if (k.startsWith('on') && typeof v==='function') n.addEventListener(k.slice(2), v);
        else n.setAttribute(k, v);
      }
      for (const k of kids) n.appendChild(typeof k==='string'?document.createTextNode(k):k);
      return n;
    }

    const state = { index:null, byPath:new Map(), byPlay:new Map(), current:null, cache:new Map(), meta:null };
    const selection = { type:null, anchor:null, focus:null };
    let awaitingFocusClick = false;
    let copyFeedbackTimer = null;
    let copyPlayFeedbackTimer = null;
    const copyButtonFeedbackTimers = new WeakMap();

    function lineElements(){
      return Array.from(document.querySelectorAll('#content .line'));
    }

    function tokenElements(){
      return Array.from(document.querySelectorAll('#content .line .token'));
    }

    function selectableLines(){
      return lineElements().filter(line=>{
        const value = (line.dataset.line || '').trim();
        return value !== '';
      });
    }

    function selectionRange(){
      const base = {type:selection.type, nodes:[], lines:[], lineStart:null, lineEnd:null, tokenCount:0, lineCount:0};
      const {anchor, focus, type} = selection;
      if (!anchor || !focus || !type) return base;
      if (type === 'line'){
        const lines = selectableLines();
        const anchorIndex = lines.indexOf(anchor);
        const focusIndex = lines.indexOf(focus);
        if (anchorIndex === -1 || focusIndex === -1) return base;
        const startIndex = Math.min(anchorIndex, focusIndex);
        const endIndex = Math.max(anchorIndex, focusIndex);
        const nodes = lines.slice(startIndex, endIndex+1);
        const lineStart = nodes[0]?.dataset.line || null;
        const lineEnd = nodes[nodes.length-1]?.dataset.line || null;
        return {
          ...base,
          nodes,
          lines:nodes,
          lineStart,
          lineEnd,
          lineCount:nodes.length
        };
      }
      if (type === 'token'){
        const tokens = tokenElements();
        const anchorIndex = tokens.indexOf(anchor);
        const focusIndex = tokens.indexOf(focus);
        if (anchorIndex === -1 || focusIndex === -1) return base;
        const startIndex = Math.min(anchorIndex, focusIndex);
        const endIndex = Math.max(anchorIndex, focusIndex);
        const nodes = tokens.slice(startIndex, endIndex+1);
        const seenLines = new Set();
        const lines = [];
        nodes.forEach(token=>{
          const line = token.closest('.line');
          if (!line) return;
          if (!seenLines.has(line)){
            seenLines.add(line);
            lines.push(line);
          }
        });
        const lineStart = lines[0]?.dataset.line || null;
        const lineEnd = lines[lines.length-1]?.dataset.line || null;
        return {
          ...base,
          nodes,
          lines,
          lineStart,
          lineEnd,
          tokenCount:nodes.length,
          lineCount:lines.length
        };
      }
      return base;
    }

    function updateSelectionHighlight(){
      const range = selectionRange();
      const selectedNodes = new Set(range.nodes);
      lineElements().forEach(line=>{
        if (selection.type === 'line' && selectedNodes.has(line)) line.classList.add('selected');
        else line.classList.remove('selected');
      });
      tokenElements().forEach(token=>{
        if (selection.type === 'token' && selectedNodes.has(token)) token.classList.add('selected');
        else token.classList.remove('selected');
      });
    }

    function setSelectionLabel(text){
      const label = $('#selection-label');
      label.textContent = text;
      if (text) label.dataset.base = text;
      else delete label.dataset.base;
    }

    function formatSelectionLabel(range){
      if (!range.nodes.length) return '';
      const {lineStart, lineEnd, type, tokenCount, lineCount} = range;
      if (lineStart && lineEnd){
        const base = lineStart === lineEnd ? `Line ${lineStart}` : `Lines ${lineStart}–${lineEnd}`;
        if (type === 'token'){
          const words = tokenCount === 1 ? ' · 1 word' : ` · ${tokenCount} words`;
          return `${base}${words}`;
        }
        if (type === 'line' && lineCount > 1){
          return `${base} · ${lineCount} lines`;
        }
        return base;
      }
      if (type === 'token'){
        return tokenCount === 1 ? '1 word' : `${tokenCount} words`;
      }
      return lineCount === 1 ? '1 line' : `${lineCount} lines`;
    }

    function updateSelectionUI(){
      const bar = $('#selection');
      const copyBtn = $('#copy-selection');
      const clearBtn = $('#clear-selection');
      const range = selectionRange();
      if (range.nodes.length){
        bar.classList.add('active');
        setSelectionLabel(formatSelectionLabel(range));
        copyBtn.disabled = false;
        clearBtn.disabled = false;
      } else {
        bar.classList.remove('active');
        setSelectionLabel('');
        copyBtn.disabled = true;
        clearBtn.disabled = true;
      }
    }

    function clearSelection(){
      selection.type = null;
      selection.anchor = null;
      selection.focus = null;
      awaitingFocusClick = false;
      updateSelectionHighlight();
      updateSelectionUI();
    }

    function flashCopyFeedback(msg){
      const label = $('#selection-label');
      const base = label.dataset.base;
      if (!base) return;
      label.textContent = `${base} · ${msg}`;
      window.clearTimeout(copyFeedbackTimer);
      copyFeedbackTimer = window.setTimeout(()=>{
        const currentBase = label.dataset.base || '';
        label.textContent = currentBase;
      }, 2000);
    }

    function speakerForLine(line){
      if (!line) return '';
      const speech = line.closest('.speech');
      if (!speech) return '';
      const speaker = speech.querySelector('.speaker');
      return speaker?.textContent.trim() || '';
    }

    function buildTokenCopy(range){
      const groups = [];
      const seen = new Map();
      range.nodes.forEach(token=>{
        const line = token.closest('.line');
        if (!line) return;
        let group = seen.get(line);
        if (!group){
          group = {line, tokens:[]};
          seen.set(line, group);
          groups.push(group);
        }
        group.tokens.push(token);
      });
      return groups.map(group=>{
        const rng = document.createRange();
        rng.setStartBefore(group.tokens[0]);
        rng.setEndAfter(group.tokens[group.tokens.length-1]);
        const raw = rng.toString().replace(/\s*\n\s*/g,' ');
        const snippet = raw.replace(/\s+/g,' ').trim();
        const num = group.line.querySelector('.line-number')?.textContent.trim() || '';
        return num ? `${num} ${snippet}` : snippet;
      }).join('\n');
    }

    function buildLineCopy(range){
      return range.nodes.map(line=>{
        const num = line.querySelector('.line-number')?.textContent.trim() || '';
        const body = line.querySelector('.line-text')?.textContent || '';
        return num ? `${num} ${body}` : body;
      }).join('\n');
    }

    function selectionDetails(range){
      const meta = state.meta || {};
      const playTitle = meta.playTitle || '';
      const unit = meta.unit || {};
      const act = unit?.act ?? null;
      const scene = unit?.scene ?? null;
      const unitTitle = meta.unitTitle || unit?.label || '';
      const speaker = speakerForLine(range.lines[0]);
      const startLine = range.lineStart;
      const endLine = range.lineEnd;
      let lineSegment = '';
      if (startLine && endLine){
        lineSegment = `Lines ${startLine} - ${endLine}`;
      }
      const headerParts = [];
      if (speaker) headerParts.push(speaker);
      if (playTitle && lineSegment) headerParts.push(`${playTitle} ${lineSegment}`);
      else if (playTitle) headerParts.push(playTitle);
      else if (lineSegment) headerParts.push(lineSegment);
      if (act != null) headerParts.push(`Act ${act}`);
      if (scene != null) headerParts.push(`Scene ${scene}`);
      else if (!scene && unitTitle && !headerParts.includes(unitTitle)) headerParts.push(unitTitle);
      const header = headerParts.join(', ');
      return {header, speaker, playTitle, act, scene, unitTitle, startLine, endLine};
    }

    function copyPayload(range){
      const details = selectionDetails(range);
      const body = range.type === 'token' ? buildTokenCopy(range) : buildLineCopy(range);
      if (!body) return '';
      const header = details.header;
      return header ? `${header}\n\n${body}` : body;
    }

    async function copySelectionRange(){
      const range = selectionRange();
      if (!range.nodes.length) return;
      const text = copyPayload(range);
      if (!text) return;
      const copied = await copyTextToClipboard(text);
      flashCopyFeedback(copied ? 'Copied!' : 'Copy failed');
    }

    async function copyTextToClipboard(text){
      if (!text) return false;
      if (navigator.clipboard?.writeText){
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch(err){
          console.error('Clipboard API copy failed', err);
        }
      }
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.setAttribute('readonly','');
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        const copied = document.execCommand('copy');
        document.body.removeChild(textarea);
        return copied;
      } catch(err){
        console.error('Fallback copy failed', err);
        return false;
      }
    }

    function spanText(span){
      if (!span) return '';
      if (typeof span.text === 'string') return span.text;
      if (Array.isArray(span.tokens)){
        return span.tokens.map(tok=>`${tok.pre||''}${tok.s||''}`).join('');
      }
      return '';
    }

    function createCopyAccumulator(){
      const normalizeLine = line => (line || '').replace(/\u00A0/g, ' ').replace(/[ \t]+$/, '');
      const trimBlankEdges = lines => {
        const copy = Array.from(lines);
        while (copy.length && copy[0].trim() === '') copy.shift();
        while (copy.length && copy[copy.length-1].trim() === '') copy.pop();
        return copy;
      };
      const output = [];
      return {
        append(lines){
          const normalized = trimBlankEdges(lines.map(normalizeLine));
          if (!normalized.length) return;
          if (output.length && output[output.length-1] !== '') output.push('');
          output.push(...normalized);
        },
        result(){
          while (output.length && output[output.length-1] === '') output.pop();
          return output.join('\n');
        }
      };
    }

    function copyContentText(){
      const content = $('#content');
      if (!content) return '';

      const acc = createCopyAccumulator();
      const appendBlock = lines => acc.append(lines);
      const stageBlockLines = node => {
        const text = node.textContent || '';
        return text.split(/\r?\n/);
      };
      const speechBlockLines = node => {
        const block = [];
        const speaker = node.querySelector('.speaker');
        if (speaker){
          const speakerText = (speaker.textContent || '').replace(/\u00A0/g, ' ').trim();
          if (speakerText) block.push(speakerText);
        }
        node.querySelectorAll('.line').forEach(line=>{
          const numberNode = line.querySelector('.line-number');
          const textNode = line.querySelector('.line-text');
          const numberRaw = (numberNode?.textContent || '').replace(/\u00A0/g, ' ');
          const textRaw = (textNode?.textContent || '').replace(/\u00A0/g, ' ');
          const number = numberRaw.trim();
          let body = textRaw.replace(/[ \t]+$/, '');
          if (number) body = body.replace(/^\s+/, '');
          const combined = number ? `${number} ${body}` : body;
          block.push(combined);
        });
        return block;
      };
      content.childNodes.forEach(node=>{
        if (node.nodeType !== 1) return;
        if (node.matches('h1.unit, .heading')){
          const text = (node.textContent || '').replace(/\u00A0/g, ' ').trim();
          if (text) appendBlock([text]);
          return;
        }
        if (node.matches('.stage')){
          appendBlock(stageBlockLines(node));
          return;
        }
        if (node.matches('.speech')){
          appendBlock(speechBlockLines(node));
          return;
        }
        const text = (node.textContent || '').replace(/\u00A0/g, ' ');
        appendBlock(text.split(/\r?\n/));
      });

      return acc.result();
    }

    function copyPlayButtonBaseLabel(){
      const meta = state.meta || {};
      const unitTitle = (meta.unitTitle || '').trim();
      const playTitle = (meta.playTitle || '').trim();
      if (unitTitle) return `Copy ${unitTitle}`;
      if (playTitle) return `Copy ${playTitle}`;
      return 'Copy text';
    }

    function copyPlayButtonAriaLabel(){
      const meta = state.meta || {};
      const unitTitle = (meta.unitTitle || '').trim();
      const playTitle = (meta.playTitle || '').trim();
      if (unitTitle && playTitle) return `Copy ${unitTitle} from ${playTitle}`;
      if (unitTitle) return `Copy ${unitTitle}`;
      if (playTitle) return `Copy ${playTitle}`;
      return 'Copy text';
    }

    function setCopyPlayFeedback(msg){
      const node = $('#copy-feedback');
      if (node) node.textContent = msg || '';
    }

    function resetCopyPlayButtonLabel(){
      const btn = $('#copy-play');
      if (!btn) return;
      const base = copyPlayButtonBaseLabel();
      btn.dataset.baseLabel = base;
      btn.textContent = base;
      btn.setAttribute('aria-label', copyPlayButtonAriaLabel());
    }

    function updateCopyPlayButton(){
      const btn = $('#copy-play');
      if (!btn) return;
      window.clearTimeout(copyPlayFeedbackTimer);
      copyPlayFeedbackTimer = null;
      resetCopyPlayButtonLabel();
      const content = $('#content');
      const hasMeta = !!state.meta;
      const hasText = hasMeta && !!content && content.innerText.trim().length > 0;
      btn.disabled = !hasText;
      if (!hasText) setCopyPlayFeedback('');
    }

    function showCopyPlayFeedback(success){
      const btn = $('#copy-play');
      if (!btn) return;
      const msg = success ? 'Copied!' : 'Copy failed';
      btn.textContent = msg;
      setCopyPlayFeedback(msg);
      window.clearTimeout(copyPlayFeedbackTimer);
      copyPlayFeedbackTimer = window.setTimeout(()=>{
        resetCopyPlayButtonLabel();
        setCopyPlayFeedback('');
      }, 2000);
    }

    async function copyEntireContent(){
      const text = copyContentText();
      if (!text){
        showCopyPlayFeedback(false);
        return;
      }
      const copied = await copyTextToClipboard(text);
      showCopyPlayFeedback(copied);
    }

    function createTokenElement(tok){
      const tokenNode = el('span',{
        class:'token',
        title:'Click to select word',
        role:'button',
        tabindex:'0'
      });
      if (tok.norm) tokenNode.dataset.norm = tok.norm;
      if (tok.type) tokenNode.dataset.type = tok.type;
      if (tok.serial) tokenNode.dataset.serial = tok.serial;
      if (tok.em) tokenNode.classList.add('em');
      tokenNode.textContent = tok.s || '';
      const label = tok.s ? `Select “${tok.s}”` : 'Select token';
      tokenNode.setAttribute('aria-label', label);
      return tokenNode;
    }

    function appendSpanContent(container, spans, {withTokens=false}={}){
      const list = Array.isArray(spans) ? spans : [];
      for (const span of list){
        const wrapper = span?.em ? el('em') : null;
        const target = wrapper || container;
        if (withTokens && Array.isArray(span?.tokens) && span.tokens.length){
          for (const tok of span.tokens){
            if (tok.pre) target.appendChild(document.createTextNode(tok.pre));
            target.appendChild(createTokenElement(tok));
          }
        } else {
          target.appendChild(document.createTextNode(spanText(span)));
        }
        if (wrapper) container.appendChild(wrapper);
      }
    }

    function applySelection(type, node, extend){
      if (!node) return;
      if (extend && selection.type === type && selection.anchor){
        selection.type = type;
        selection.focus = node;
        awaitingFocusClick = false;
      } else {
        selection.type = type;
        selection.anchor = node;
        selection.focus = node;
        awaitingFocusClick = true;
      }
      updateSelectionHighlight();
      updateSelectionUI();
    }

    function handleTokenSelection(token, event){
      const line = token.closest('.line');
      const value = (line?.dataset.line || '').trim();
      if (!line || !value) return;
      const extend = (event.shiftKey || awaitingFocusClick) && selection.type === 'token';
      applySelection('token', token, extend);
    }

    function handleLineSelection(line, event){
      const value = (line?.dataset.line || '').trim();
      if (!line || !value) return;
      const extend = (event.shiftKey || awaitingFocusClick) && selection.type === 'line';
      applySelection('line', line, extend);
    }

    $('#content').addEventListener('click', e=>{
      const token = e.target.closest('.token');
      if (token){
        e.preventDefault();
        e.stopPropagation();
        handleTokenSelection(token, e);
        return;
      }

      const line = e.target.closest('.line');
      if (!line) return;
      handleLineSelection(line, e);
    });

    $('#content').addEventListener('keydown', e=>{
      const token = e.target.closest('.token');
      if (!token) return;
      if (e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        handleTokenSelection(token, e);
      }
    });

    document.addEventListener('click', e=>{
      if (!selectionRange().nodes.length) return;
      if (e.target.closest('.line, .token, #selection')) return;
      clearSelection();
    });

    $('#clear-selection').addEventListener('click', e=>{
      e.preventDefault();
      clearSelection();
    });

    $('#copy-selection').addEventListener('click', e=>{
      e.preventDefault();
      copySelectionRange();
    });

    clearSelection();
    updateCopyPlayButton();

    $('#copy-play').addEventListener('click', e=>{
      e.preventDefault();
      if (e.currentTarget?.disabled) return;
      copyEntireContent();
    });

    async function loadIndex(){
      const res = await fetch('index.json');               // IMPORTANT: relative path (works at /shakespeare-JSON/)
      if (!res.ok) throw new Error('Failed to load index.json: '+res.status);
      const idx = await res.json();
      state.index = idx;
      state.byPath.clear();
      idx.plays.forEach((p,pi)=>p.scenes.forEach((s,si)=>state.byPath.set(s.path,{playIndex:pi,sceneIndex:si})));
    }

    function renderSidebar(){
      const root = $('#plays'); root.innerHTML = '';
      state.index.plays.forEach(play=>{
        const details = el('details',{class:'play'});
        details.appendChild(el('summary',{}, play.title+' ', el('small',{class:'muted'},`(${play.scene_count})`)));
        const ul = el('ul',{class:'scenes'});
        const grouped = new Map();
        ul.appendChild(el('li',{}, el('a',{
          href:'#p='+encodeURIComponent(play.id),
          class:'scene-link full',
          'data-play':play.id
        }, 'Full play')));
        play.scenes.forEach(s=>{
          const act = s.act ?? 'Other';
          if (!grouped.has(act)) grouped.set(act, []);
          grouped.get(act).push(s);
        });
        const sortedActs = Array.from(grouped.keys()).sort((a,b)=>{
          if (typeof a === 'number' && typeof b === 'number') return a-b;
          if (typeof a === 'number') return -1;
          if (typeof b === 'number') return 1;
          return String(a).localeCompare(String(b));
        });
        sortedActs.forEach(act=>{
          const scenes = grouped.get(act);
          const actTitle = typeof act === 'number' ? `Act ${act}` : String(act);
          const li = el('li',{class:'act-group'});
          const header = el('div',{class:'act-header'});
          header.appendChild(el('div',{class:'act-title'}, actTitle));
          const copyBtn = el('button',{type:'button',class:'act-copy'}, 'Copy');
          const ariaLabel = `Copy ${actTitle} from ${play.title}`;
          setupCopyButton(copyBtn, 'Copy', ariaLabel);
          copyBtn.addEventListener('click', e=>{
            e.preventDefault();
            handleActCopy(copyBtn, {
              playId: play.id,
              actKey: act,
              actTitle,
              playTitle: play.title
            });
          });
          header.appendChild(copyBtn);
          li.appendChild(header);
          const list = el('ul',{class:'scene-items'});
          scenes.forEach(s=>{
            const label = s.title || (typeof s.scene === 'number' ? `Scene ${s.scene}` : s.scene || 'Scene');
            const li = el('li',{});
            const row = el('div',{class:'scene-item'});
            const a = el('a',{href:'#s='+encodeURIComponent(s.path), class:'scene-link', 'data-path':s.path}, label);
            row.appendChild(a);
            const copyBtn = el('button',{type:'button',class:'act-copy scene-copy'}, 'Copy');
            const ariaLabel = `Copy ${label} from ${play.title}`;
            setupCopyButton(copyBtn, 'Copy', ariaLabel);
            copyBtn.addEventListener('click', e=>{
              e.preventDefault();
              e.stopPropagation();
              handleSceneCopy(copyBtn, {
                scenePath: s.path,
                sceneLabel: label,
                playTitle: play.title
              });
            });
            row.appendChild(copyBtn);
            li.appendChild(row);
            list.appendChild(li);
          });
          li.appendChild(list);
          ul.appendChild(li);
        });
        details.appendChild(ul);
        root.appendChild(details);
      });
    }

    function textFromItem(item){
      const spans = item.spans || [];
      return spans.map(sp=>sp.text || '').join('');
    }

    function copyTextFromItems(items){
      const acc = createCopyAccumulator();
      const appendBlock = lines => acc.append(lines);
      let currentSpeech = null;
      let lastSpeechId = null;
      let pendingSpeaker = null;

      const flushSpeech = () => {
        if (!currentSpeech) return;
        const block = [];
        if (currentSpeech.speaker) block.push(currentSpeech.speaker);
        block.push(...currentSpeech.lines);
        appendBlock(block);
        currentSpeech = null;
        lastSpeechId = null;
      };

      const speakerName = value => (value || '').replaceAll('_',' ').replace(/\u00A0/g, ' ').trim();

      for (const item of items || []){
        if (!item) continue;
        if (item.kind === 'speech'){
          const speechId = item.speech_id ?? null;
          if (!currentSpeech || speechId !== lastSpeechId){
            flushSpeech();
            const speakerRaw = pendingSpeaker || item.speaker || '';
            const speaker = speakerName(speakerRaw);
            currentSpeech = {speaker, lines:[]};
            lastSpeechId = speechId;
            pendingSpeaker = null;
          }
          const numberRaw = item.line_number != null ? String(item.line_number) : '';
          const textRaw = (item.spans || []).map(spanText).join('').replace(/\u00A0/g, ' ');
          let body = textRaw.replace(/[ \t]+$/, '');
          if (numberRaw) body = body.replace(/^\s+/, '');
          const combined = numberRaw ? `${numberRaw} ${body}` : body;
          currentSpeech.lines.push(combined);
          continue;
        }
        if (item.kind === 'speaker_label'){
          pendingSpeaker = speakerName(item.speaker || '');
          flushSpeech();
          continue;
        }
        flushSpeech();
        if (item.kind === 'stage'){
          const stageText = (item.spans || []).map(spanText).join('');
          appendBlock(stageText.split(/\r?\n/));
          continue;
        }
        if (item.kind === 'heading'){
          const headingText = textFromItem(item).replace(/\u00A0/g, ' ');
          appendBlock([headingText]);
          continue;
        }
        const fallbackText = (item.spans || []).map(spanText).join('');
        appendBlock(fallbackText.split(/\r?\n/));
      }
      flushSpeech();
      return acc.result();
    }

    async function copyActContent(playId, actKey){
      const play = state.byPlay.get(playId);
      if (!play) return '';
      const matchingScenes = play.scenes.filter(scene => ((scene.act ?? 'Other') === actKey));
      if (!matchingScenes.length) return '';
      const scenes = await Promise.all(matchingScenes.map(scene=>fetchJSON(scene.path)));
      const items = scenes.flatMap(scene=>scene.items || []);
      return copyTextFromItems(items);
    }

    async function copySceneContent(scenePath){
      if (!scenePath) return '';
      const scene = await fetchJSON(scenePath);
      return copyTextFromItems(scene.items || []);
    }

    function setupCopyButton(button, label, ariaLabel){
      if (!button) return;
      button.dataset.baseLabel = label;
      if (ariaLabel){
        button.dataset.baseAriaLabel = ariaLabel;
        button.setAttribute('aria-label', ariaLabel);
        button.title = ariaLabel;
      } else {
        delete button.dataset.baseAriaLabel;
        button.removeAttribute('aria-label');
        button.removeAttribute('title');
      }
      button.textContent = label;
    }

    function resetCopyButton(button){
      if (!button) return;
      const base = button.dataset.baseLabel || 'Copy';
      button.textContent = base;
      const aria = button.dataset.baseAriaLabel;
      if (aria){
        button.setAttribute('aria-label', aria);
        button.title = aria;
      } else {
        button.removeAttribute('aria-label');
        button.removeAttribute('title');
      }
      copyButtonFeedbackTimers.delete(button);
    }

    function showCopyFeedback(button, success){
      if (!button) return;
      const msg = success ? 'Copied!' : 'Copy failed';
      const baseAria = button.dataset.baseAriaLabel || '';
      const aria = baseAria ? `${msg}. ${baseAria}` : msg;
      button.textContent = msg;
      button.setAttribute('aria-label', aria);
      button.title = aria;
      const existing = copyButtonFeedbackTimers.get(button);
      if (existing) window.clearTimeout(existing);
      const timer = window.setTimeout(()=>{ resetCopyButton(button); }, 2000);
      copyButtonFeedbackTimers.set(button, timer);
    }

    async function handleCopyAction(button, {copyingAria, getText, errorContext}){
      if (!button || button.disabled) return;
      const existing = copyButtonFeedbackTimers.get(button);
      if (existing) window.clearTimeout(existing);
      copyButtonFeedbackTimers.delete(button);
      button.disabled = true;
      button.textContent = 'Copying…';
      if (copyingAria){
        button.setAttribute('aria-label', copyingAria);
        button.title = copyingAria;
      } else {
        button.removeAttribute('aria-label');
        button.removeAttribute('title');
      }
      try {
        const text = await getText();
        const success = text ? await copyTextToClipboard(text) : false;
        showCopyFeedback(button, success);
      } catch(err){
        if (errorContext) console.error(errorContext, err);
        else console.error('Failed to copy content', err);
        showCopyFeedback(button, false);
      } finally {
        button.disabled = false;
      }
    }

    async function handleActCopy(button, {playId, actKey, actTitle, playTitle}){
      const copyingAria = `Copying ${actTitle} from ${playTitle}`;
      return handleCopyAction(button, {
        copyingAria,
        getText: ()=>copyActContent(playId, actKey),
        errorContext: 'Failed to copy act'
      });
    }

    async function handleSceneCopy(button, {scenePath, sceneLabel, playTitle}){
      const copyingAria = `Copying ${sceneLabel} from ${playTitle}`;
      return handleCopyAction(button, {
        copyingAria,
        getText: ()=>copySceneContent(scenePath),
        errorContext: `Failed to copy scene "${sceneLabel}"`
      });
    }

    function renderScene(json,{playTitle:playOverride,unitTitle:unitOverride}={}){
      const playTitle = playOverride || json.meta?.play?.title || json.meta?.play?.id || 'Unknown play';
      let unitTitle;
      if (unitOverride !== undefined) unitTitle = unitOverride;
      else unitTitle = json.meta?.unit?.title || json.meta?.unit?.label || '';
      state.meta = {
        playTitle,
        playId: json.meta?.play?.id || '',
        unit: json.meta?.unit || null,
        unitTitle
      };
      $('#crumbs').textContent = unitTitle ? `${playTitle} › ${unitTitle}` : playTitle;

      const content = $('#content'); content.innerHTML = '';
      if (unitTitle) content.appendChild(el('h1',{class:'unit'}, unitTitle));

      let lastSpeechId = null, cur = null;
      let pendingSpeaker = null;
      clearSelection();
      for (const item of (json.items || [])){
        if (item.kind === 'heading'){
          const level = (item.subtype==='scene' || item.subtype==='title') ? 'h2' : 'h3';
          content.appendChild(el(level,{class:'heading '+(item.subtype||'')}, textFromItem(item)));
          lastSpeechId = null; cur = null; pendingSpeaker = null;
        } else if (item.kind === 'stage'){
          const stage = el('div',{class:'stage'});
          appendSpanContent(stage, item.spans,{withTokens:true});
          content.appendChild(stage);
        } else if (item.kind === 'speech'){
          if (item.speech_id !== lastSpeechId){
            cur = el('section',{class:'speech'});
            const speakerRaw = pendingSpeaker || item.speaker || '';
            const speaker = speakerRaw.replaceAll('_',' ').trim();
            if (speaker) cur.appendChild(el('h4',{class:'speaker'}, speaker));
            content.appendChild(cur);
            lastSpeechId = item.speech_id;
            pendingSpeaker = null;
          }
          const line = el('p',{class:'line','data-line':item.line_number ?? ''});
          const ln = item.line_number ? String(item.line_number) : '\u00A0';
          line.appendChild(el('span',{class:'line-number'}, ln));
          const lineText = el('span',{class:'line-text'});
          appendSpanContent(lineText, item.spans,{withTokens:true});
          line.appendChild(lineText);
          cur.appendChild(line);
        } else if (item.kind === 'speaker_label'){
          pendingSpeaker = (item.speaker||'').replaceAll('_',' ').trim();
          cur = null;
          lastSpeechId = null;
        }
      }
      content.scrollTop = 0;
      updateSelectionUI();
      updateCopyPlayButton();
    }

    async function fetchJSON(path){
      if (state.cache.has(path)) return state.cache.get(path);
      const res = await fetch(path);
      if (!res.ok) throw new Error(`Failed to load ${path}: ${res.status}`);
      const json = await res.json();
      state.cache.set(path,json);
      return json;
    }

    function setActiveLink(selector){
      document.querySelectorAll('.scene-link.active').forEach(a=>a.classList.remove('active'));
      if (selector){
        const node = document.querySelector(selector);
        node?.classList.add('active');
        node?.closest('details')?.setAttribute('open','');
      }
    }

    async function loadSceneByPath(path){
      // highlight active & open the play
      setActiveLink(`.scene-link[data-path="${CSS.escape(path)}"]`);

      // prev/next within the same play
      const loc = state.byPath.get(path);
      if (!loc) throw new Error(`Unknown scene: ${path}`);
      const play = state.index.plays[loc.playIndex];
      const prev = play.scenes[loc.sceneIndex-1];
      const next = play.scenes[loc.sceneIndex+1];
      $('#prev').disabled = !prev; $('#next').disabled = !next;
      $('#prev').onclick = prev ? ()=>navigateTo(prev.path) : null;
      $('#next').onclick = next ? ()=>navigateTo(next.path) : null;

      const key = `scene:${path}`;
      state.current = key;
      try {
        const json = await fetchJSON(path);
        renderScene(json);
      } catch(err){
        state.current = null;
        throw err;
      }
    }

    async function loadPlayById(id){
      const play = state.byPlay.get(id);
      if (!play) throw new Error(`Unknown play: ${id}`);
      setActiveLink(`.scene-link.full[data-play="${CSS.escape(id)}"]`);
      $('#prev').disabled = true; $('#next').disabled = true;
      $('#prev').onclick = null; $('#next').onclick = null;

      const key = `play:${id}`;
      state.current = key;
      try {
        const scenes = await Promise.all(play.scenes.map(s=>fetchJSON(s.path)));
        if (!scenes.length) throw new Error(`Play has no scenes: ${id}`);
        const items = scenes.flatMap(s=>s.items || []);
        const combined = {
          meta: { play: scenes[0].meta?.play },
          items
        };
        renderScene(combined,{playTitle:play.title, unitTitle:'Full Play'});
      } catch(err){
        state.current = null;
        throw err;
      }
    }

    function navigateTo(path){ location.hash = '#s=' + encodeURIComponent(path); }
    function navigateToPlay(id){ location.hash = '#p=' + encodeURIComponent(id); }
    function hashState(){
      const scene = location.hash.match(/#s=([^&]+)/);
      if (scene) return {type:'scene', value:decodeURIComponent(scene[1])};
      const play = location.hash.match(/#p=([^&]+)/);
      if (play) return {type:'play', value:decodeURIComponent(play[1])};
      return null;
    }

    function showError(err){
      const content = $('#content'); content.innerHTML = '';
      content.appendChild(el('div',{class:'error'}, `⚠️ ${err.message}\nOpen DevTools → Console for details.`));
      state.meta = null;
      updateCopyPlayButton();
      console.error(err);
    }

    window.addEventListener('hashchange', ()=>{
      const target = hashState();
      if (!target) return;
      const key = `${target.type}:${target.value}`;
      if (key === state.current) return;
      const loader = target.type === 'scene' ? loadSceneByPath(target.value) : loadPlayById(target.value);
      Promise.resolve(loader).catch(showError);
    });

    window.addEventListener('keydown', e=>{
      if (e.key==='ArrowLeft' && !$('#prev').disabled) $('#prev').click();
      if (e.key==='ArrowRight' && !$('#next').disabled) $('#next').click();
      if (e.key==='Escape') clearSelection();
    });

    (async function start(){
      await loadIndex();
      state.byPlay.clear();
      state.index.plays.forEach(p=>state.byPlay.set(p.id,p));
      renderSidebar();
      let target = hashState();
      if (!target){
        const firstPlay = state.index.plays[0];
        if (firstPlay){
          navigateToPlay(firstPlay.id);
          target = {type:'play', value:firstPlay.id};
        }
      }
      if (target){
        if (target.type==='scene') await loadSceneByPath(target.value);
        else await loadPlayById(target.value);
      }
    })().catch(showError);
  })();
  </script>
</body>
</html>
